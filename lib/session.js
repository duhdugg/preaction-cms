const bcrypt = require('bcryptjs')
const express = require('express')
const session = require('express-session')
const SessionStore = require('connect-session-sequelize')(session.Store)
const cache = require('./cache.js')
const csrf = require('./csrf.js')
const db = require('./db.js')
const env = require('./env.js')
const renderClient = require('./render.js').renderClient

const oneYear = 365 * 24 * 60 * 60 * 1000
const sessionConfig = {
  secret: env.cookieSecret,
  name: env.sessionCookieName,
  cookie: {
    maxAge: oneYear,
    sameSite: env.cookieSameSite,
    secure: env.cookieSecure,
  },
  store: new SessionStore({
    db: db.sequelizeAuth,
    expiration: oneYear,
    extendDefaultFields: db.extendDefaultSessionFields,
    table: 'session',
  }),
  proxy: env.proxy,
  resave: false,
  saveUninitialized: false,
}

const middleware = express()

// <== FUNCTIONS ==>

// authenticationRequired is a middleware function to require
// that the session is authenticated before proceeding
// to the next middleware function
const authenticationRequired = (req, res, next) => {
  if (req.session.authenticated) {
    next()
  } else {
    res.status(401).json({ error: 'unauthorized' })
  }
}

// uses Math.random for basic password initialization
const randomString = (length) => {
  const possibleChars =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' +
    '~!@#$%^&*()-_=+[]{}\\|;:,.<>/?'
  let s = ''
  while (s.length < length) {
    const charIndex = Math.round(Math.random() * possibleChars.length)
    s += possibleChars[charIndex]
  }
  return s
}

// ensures that an admin user is created
// the promise will resolve if the user already exists
// if a user does not exist, then it will create one
// using a randomized password generated by randomString
// and hashed with bcrypt
const createDefaultUser = async () => {
  const salt = bcrypt.genSaltSync()
  const unhashedPw = randomString(24)
  const password = bcrypt.hashSync(unhashedPw, salt)
  const username = 'admin'
  const [user, created] = await db.model.User.findOrCreate({
    where: { username: 'admin' },
    defaults: { username, password },
  })
  if (created) {
    const log = (msg) => {
      if (env.nodeEnv !== 'test') {
        console.log(msg)
      }
    }
    log('--- credentials set! ---')
    log(`username: ${username}`)
    log(`password: ${unhashedPw}`)
    log('see README.md to change')
    log('---')
  }
  return [user, created]
}

// updates the admin password, hashed with bcrypt
const updateAdminPassword = async (pw) => {
  await createDefaultUser()
  const salt = bcrypt.genSaltSync()
  const password = bcrypt.hashSync(pw, salt)
  await db.model.User.update(
    { password },
    {
      where: { username: 'admin' },
    }
  )
  db.backup()
  return
}

const sync = async () => {
  const defaultUser = await createDefaultUser()
  return { defaultUser }
}

// <== EXPRESS MODULE ROUTES ==>

// displays the login page
middleware.route('/login').get(cache.middleware, (req, res) => {
  renderClient(req, res.status(200))
})

// returns the current session as json
middleware.route('/api/session').get(async (req, res, next) => {
  if (env.readOnly) {
    res.json({})
    return
  }
  // work with serializeable copy of session object
  const session = JSON.parse(JSON.stringify(req.session))
  res.json(session)
})

middleware.route('/api/token').get((req, res, next) => {
  // ensure the session has a unique token
  if (!req.session.token && !env.readOnly) {
    const timestamp = +new Date()
    const rando = Math.random()
    const token = `${timestamp}:${rando}`
    req.session.token = token
  }
  res.json(req.session.token)
})

// handles login requests to authentication the session
// using bcrypt to compare the password
middleware.route('/api/login').post(csrf.protect, async (req, res, next) => {
  if (!req.body.username) {
    res.status(400).json({ error: 'username is required' })
    return
  }
  if (!req.body.password) {
    res.status(400).json({ error: 'password is required' })
    return
  }
  const user = await db.model.User.findOne({
    where: { username: req.body.username },
  })
  if (!user) {
    res.status(401).json({})
  } else {
    bcrypt.compare(req.body.password, user.password, function (err, response) {
      if (err) {
        res.status(401).json(err)
      } else if (response) {
        req.session.userId = user.id
        req.session.authenticated = true
        if (user.username === 'admin') {
          req.session.admin = true
        }
        res.json(JSON.parse(JSON.stringify(req.session)))
      } else {
        res.status(401).json({})
      }
    })
  }
})

// handles logout requests to de-authenticate the session
middleware
  .route('/api/logout')
  .get(authenticationRequired, csrf.protect, (req, res) => {
    req.session.admin = false
    req.session.authenticated = false
    req.session.userId = undefined
    res.json(true)
  })

// <== EXPORT ==>

module.exports = {
  authenticationRequired,
  updateAdminPassword,
  session: session(sessionConfig),
  middleware,
  sync,
}
