/**
 * @module session
 */

const bcrypt = require('bcryptjs')
const express = require('express')
const session = require('express-session')
const SessionStore = require('connect-session-sequelize')(session.Store)
const cache = require('./cache.js')
const csrf = require('./csrf.js')
const db = require('./db.js')
const env = require('./env.js')
const renderClient = require('./render.js').renderClient

const oneYear = 365 * 24 * 60 * 60 * 1000
const sessionConfig = {
  secret: env.cookieSecret,
  name: env.sessionCookieName,
  cookie: {
    maxAge: oneYear,
    sameSite: env.cookieSameSite,
    secure: env.cookieSecure,
  },
  store: new SessionStore({
    db: db.sequelizeAuth,
    expiration: oneYear,
    extendDefaultFields: db.extendDefaultSessionFields,
    table: 'session',
  }),
  proxy: env.proxy,
  resave: false,
  saveUninitialized: false,
}

/**
 * @memberof session
 * @type {express}
 * @description handles login, session, and token API
 * @see {@link https://expressjs.com/en/guide/using-middleware.html}
 */
const middleware = express()

// <== FUNCTIONS ==>

/**
 * @memberof session
 * @function
 * @param {express.Request} req
 * @param {express.Response} res
 * @param {func} next
 * @description middleware function to require that the session is
 * authenticated before proceeding to the next middleware function.
 * Otherwise, a 401 unauthorized response error is returned
 * @see {@link https://expressjs.com/en/guide/using-middleware.html}
 */
const authenticationRequired = (req, res, next) => {
  if (req.session.authenticated) {
    next()
  } else {
    res.status(401).json({ error: 'unauthorized' })
  }
}

// uses Math.random for basic password initialization
const randomString = (length) => {
  const possibleChars =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' +
    '~!@#$%^&*()-_=+[]{}\\|;:,.<>/?'
  let s = ''
  while (s.length < length) {
    const charIndex = Math.round(Math.random() * possibleChars.length)
    s += possibleChars[charIndex]
  }
  return s
}

// ensures that an admin user is created
// the promise will resolve if the user already exists
// if a user does not exist, then it will create one
// using a randomized password generated by randomString
// and hashed with bcrypt
const createDefaultUser = async () => {
  const salt = bcrypt.genSaltSync()
  const unhashedPw = randomString(24)
  const password = bcrypt.hashSync(unhashedPw, salt)
  const username = 'admin'
  const [user, created] = await db.model.User.findOrCreate({
    where: { username: 'admin' },
    defaults: { username, password },
  })
  if (created) {
    const log = (msg) => {
      if (env.nodeEnv !== 'test') {
        console.log(msg)
      }
    }
    log('--- credentials set! ---')
    log(`username: ${username}`)
    log(`password: ${unhashedPw}`)
    log('see README.md to change')
    log('---')
  }
  return [user, created]
}

/**
 * @memberof session
 * @function
 * @param {string} pw
 * @description updates the admin user's password using bcrypt
 * @returns {Promise} `undefined`
 */
// updates the admin password, hashed with bcrypt
const updateAdminPassword = async (pw) => {
  await createDefaultUser()
  const salt = bcrypt.genSaltSync()
  const password = bcrypt.hashSync(pw, salt)
  await db.model.User.update(
    { password },
    {
      where: { username: 'admin' },
    }
  )
  db.backup()
  return
}

/**
 * @memberof session
 * @description ensures that the default user is created
 * @returns {Promise} `[ { Object } user, { boolean } created ]`
 */
const sync = async () => {
  const defaultUser = await createDefaultUser()
  return { defaultUser }
}

// <== EXPRESS MODULE ROUTES ==>

/**
 * @memberof session.middleware
 * @name GET-login
 * @description renders the application (which should route to login page)
 * @returns {string} text/html
 */
middleware.route('/login').get(cache.middleware, (req, res) => {
  renderClient(req, res.status(200))
})

/**
 * @memberof session.middleware
 * @name GET-api/session
 * @returns {Object} session variables
 */
middleware.route('/api/session').get(async (req, res, next) => {
  if (env.readOnly) {
    res.json({})
    return
  }
  // work with serializeable copy of session object
  const session = JSON.parse(JSON.stringify(req.session))
  res.json(session)
})

/**
 * @memberof session.middleware
 * @name GET-api/token
 * @param {express.Request} req
 * @param {express.Response} res
 * @param {func} next
 * @returns {string} CSRF token
 */
middleware.route('/api/token').get((req, res, next) => {
  // ensure the session has a unique token
  if (!req.session.token && !env.readOnly) {
    const timestamp = +new Date()
    const rando = Math.random()
    const token = `${timestamp}:${rando}`
    req.session.token = token
  }
  res.json(req.session.token)
})

/**
 * @memberof session.middleware
 * @name POST-api/login
 * @param {express.Request} req
 * @param {Object} req.body as JSON
 * @param {string} req.body.username
 * @param {string} req.body.password
 * @param {express.Response} res
 * @param {func} next
 * @description handles login requests to authenticate the session
 * using bcrypt to compare the password
 * @returns {Object} `req.session` and status = 200 if valid, otherwise `{}` and 401
 */
middleware.route('/api/login').post(csrf.protect, async (req, res, next) => {
  if (!req.body.username) {
    res.status(400).json({ error: 'username is required' })
    return
  }
  if (!req.body.password) {
    res.status(400).json({ error: 'password is required' })
    return
  }
  const user = await db.model.User.findOne({
    where: { username: req.body.username },
  })
  if (!user) {
    res.status(401).json({})
  } else {
    bcrypt.compare(req.body.password, user.password, function (err, response) {
      if (err) {
        res.status(401).json(err)
      } else if (response) {
        req.session.userId = user.id
        req.session.authenticated = true
        if (user.username === 'admin') {
          req.session.admin = true
        }
        res.json(JSON.parse(JSON.stringify(req.session)))
      } else {
        res.status(401).json({})
      }
    })
  }
})

/**
 * @memberof session.middleware
 * @name GET-api/logout
 * @param {express.Request} req
 * @param {express.Response} res
 * @param {func} next
 * @description handles logout requests to de-authenticate the session
 * @returns {boolean} `true`
 */
middleware
  .route('/api/logout')
  .get(authenticationRequired, csrf.protect, (req, res) => {
    req.session.admin = false
    req.session.authenticated = false
    req.session.userId = undefined
    res.json(true)
  })

// <== EXPORT ==>

module.exports = {
  authenticationRequired,
  updateAdminPassword,
  /**
   * @memberof session
   * @type {express-session}
   */
  session: session(sessionConfig),
  middleware,
  sync,
}
