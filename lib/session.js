const bcrypt = require('bcryptjs')
const express = require('express')
const session = require('express-session')
const SessionStore = require('connect-session-sequelize')(session.Store)
const cache = require('./cache.js')
const csrf = require('./csrf.js')
const db = require('./db.js')
const env = require('./env.js')
const renderClient = require('./render.js').renderClient

const oneYear = 365 * 24 * 60 * 60 * 1000
const sessionConfig = {
  secret: env.cookieSecret,
  name: env.sessionCookieName,
  cookie: {
    maxAge: oneYear,
    sameSite: env.cookieSameSite,
    secure: env.cookieSecure,
  },
  store: new SessionStore({
    db: db.sequelizeAuth,
    expiration: oneYear,
    extendDefaultFields: db.extendDefaultSessionFields,
    table: 'session',
  }),
  proxy: env.proxy,
  resave: false,
  saveUninitialized: false,
}

const middleware = express()

// <== FUNCTIONS ==>

// authenticationRequired is a middleware function to require
// that the session is authenticated before proceeding
// to the next middleware function
const authenticationRequired = (req, res, next) => {
  if (req.session.authenticated) {
    next()
  } else {
    res.status(401).json({ error: 'unauthorized' })
  }
}

// uses Math.random for basic password initialization
const randomString = (length) => {
  const possibleChars =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' +
    '~!@#$%^&*()-_=+[]{}\\|;:,.<>/?'
  let s = ''
  while (s.length < length) {
    let charIndex = Math.round(Math.random() * possibleChars.length)
    s += possibleChars[charIndex]
  }
  return s
}

// ensures that an admin user is created
// the promise will resolve if the user already exists
// if a user does not exist, then it will create one
// using a randomized password generated by randomString
// and hashed with bcrypt
const createDefaultUser = () =>
  new Promise((resolve, reject) => {
    let salt = bcrypt.genSaltSync()
    let unhashedPw = randomString(24)
    let password = bcrypt.hashSync(unhashedPw, salt)
    let username = 'admin'
    db.model.User.findOrCreate({
      where: { username: 'admin' },
      defaults: { username, password },
    }).then(([user, created]) => {
      if (created) {
        const log = (msg) => {
          if (env.nodeEnv !== 'test') {
            console.log(msg)
          }
        }
        log('--- credentials set! ---')
        log(`username: ${username}`)
        log(`password: ${unhashedPw}`)
        log('see README.md to change')
        log('---')
      }
      resolve([user, created])
    })
  })

// updates the admin password, hashed with bcrypt
const updateAdminPassword = (pw) => {
  return new Promise((resolve, reject) => {
    createDefaultUser().then(() => {
      let salt = bcrypt.genSaltSync()
      let password = bcrypt.hashSync(pw, salt)
      db.model.User.update(
        { password },
        {
          where: { username: 'admin' },
        }
      ).then(() => {
        db.backup()
        resolve()
      })
    })
  })
}

const sync = () =>
  new Promise((resolve, reject) => {
    createDefaultUser().then(resolve)
  })

// <== EXPRESS MODULE ROUTES ==>

// displays the login page
middleware.route('/login').get(cache.middleware, (req, res) => {
  renderClient(req, res.status(200))
})

// returns the current session as json
middleware.route('/api/session').get((req, res, next) => {
  if (env.readOnly) {
    res.json({})
    return
  }
  // work with serializeable copy of session object
  const session = JSON.parse(JSON.stringify(req.session))
  if (session.userId) {
    db.model.User.findByPk(session.userId).then((user) => {
      res.json(session)
    })
  } else {
    res.json(session)
  }
})

middleware.route('/api/token').get((req, res, next) => {
  // ensure the session has a unique token
  if (!req.session.token && !env.readOnly) {
    const timestamp = +new Date()
    const rando = Math.random()
    const token = `${timestamp}:${rando}`
    req.session.token = token
  }
  res.json(req.session.token)
})

// handles login requests to authentication the session
// using bcrypt to compare the password
middleware.route('/api/login').post(csrf.protect, (req, res, next) => {
  if (!req.body.username) {
    res.status(400).json({ error: 'username is required' })
    return
  }
  if (!req.body.password) {
    res.status(400).json({ error: 'password is required' })
    return
  }
  db.model.User.findOne({
    where: { username: req.body.username },
  }).then((user) => {
    if (!user) {
      res.status(401).json({})
    } else {
      bcrypt.compare(req.body.password, user.password, function (
        err,
        response
      ) {
        if (err) {
          res.status(401).json(err)
        } else if (response) {
          req.session.userId = user.id
          req.session.authenticated = true
          if (user.username === 'admin') {
            req.session.admin = true
          }
          res.json(JSON.parse(JSON.stringify(req.session)))
        } else {
          res.status(401).json({})
        }
      })
    }
  })
})

// handles logout requests to de-authenticate the session
middleware
  .route('/api/logout')
  .get(authenticationRequired, csrf.protect, (req, res) => {
    req.session.admin = false
    req.session.authenticated = false
    req.session.userId = undefined
    res.json(true)
  })

// <== EXPORT ==>

module.exports = {
  authenticationRequired,
  updateAdminPassword,
  session: session(sessionConfig),
  middleware,
  sync,
}
